% Breakpoint
% Sébastien Boisgérault
% Saturday, 08 March 2014


Preamble
--------------------------------------------------------------------------------

    from __future__ import division
    import time

Using Generator to Break Long-Running Functions
--------------------------------------------------------------------------------

Basic operation:

    result = compute(result)

Encapsulate instead and call the function ?

    def compute(value):
        time.sleep(0.1)
        return value + 1

That's our simulation of compute computation. Long-running operations are
sequences of such operations.

    def count_to_three():
        result = 0
        result = compute(result)
        result = compute(result)
        result = compute(result)
        return result

Using it:

    >>> count_to_three():
    3

Intermediate version ? With `yield` and `yield None, result` at the end ?
That seems artificial (the end), could we accept `yield result` without
ambiguity ? Unfortunately, no, we would need an extra option in the 
decorator and it's not worth it. State that it's a convention we use 
that is going to get explained shortly.

Generator version (minimal): **Is the support for the bare `yield`
interesting of misleading ?** Present something that COULD NOT be
wrapped with breakpoint, but that lays down the main idea.

    def count_to_three():
        result = 0
        yield
        result = compute(result)
        yield
        result = compute(result)
        yield
        result = compute(result)
        yield result

Using it:

    >>> counter = count_to_three()
    >>> counter.next()
    >>> counter.next()
    >>> counter.next()
    >>> counter.next()
    3

Version not very useful: we have split the info, but no criteria to actually
do something useful in the steps. Hence progress and partial result.

Generator version: progress and partial result

    def count_to_three():
        result = 0
        yield 0 / 3, result
        result = compute(result)
        yield 1 / 3, result
        result = compute(result)
        yield 2 / 3, result
        result = compute(result)
        yield 3 / 3, result

generator version with progress and partial result: explain 3 ops,
hence progress computation. Explain partial result. Those two results
are optional (replacable by None). If you don't care at all, `yield`
(aka `yield None`) is OK too.

State that progress is optional (`None` if you don't know)

Using it:

    >>> counter = count_to_three()
    >>> counter.next()
    (0.0, 0)
    >>> counter.next()
    (0.3333333333333333, None)
    >>> counter.next()
    (0.6666666666666666, None)
    >>> counter.next()
    (1.0, None)


Loop version, explicit progress, partial result

    def count_to(n):
        result = 0
        for i in range(n):
            result = compute(result)
        return result

Using it:

    >>> count_to(3)
    3

    def count_to(n):
        result = 0
        for i in range(n):
            progress = i / n
            yield progress, result 
            result = compute(result)
        return result


Breakpoint Decorators and Handlers
--------------------------------------------------------------------------------


Restore the original function behavior (reverse the split) from the generator:

**Question:** rename `breakpoint` decorator `function` ?

    @breakpoint()
    def count_to(n):
        result = 0
        for i in range(n):
            progress = i / n
            yield progress, result 
            result = compute(result)
        return result

Using it:

    >>> count_to(3)
    3

So why the hell did we tweak the original function ? Because we
have new options now such as: because now we can track the evolution
of the computation. For example, display partial results:

    def partial():
        def handler(**kwargs):
            print kwargs.get("progress"), kwargs.get("result")
        return handler

Decorate `count_to` like this:

    @breakpoint(partial)
    def count_to(n):
        result = 0
        for i in range(n):
            progress = i / n
            yield progress, result 
            result = compute(result)
        return result

Use it like this:

    >>> count_to(3)
    (0.0, 0)
    (0.3333333333333333, 1)
    (0.6666666666666666, 2)
    (1.0, 3)
    3

Available information for the handler: includes what you returned in the yield, 
that is `progress`, `result`. There is more, so make sure to use `**kwargs`.

Explain handler factory (closure): every time your run, a new instance of the 
handler is generated. For example:

    def partial():
       start = True
       def handler(**kwargs):
           nonlocal start # not in Python 2.7 !
           if start:
               print "first handler call"
               start = False
           print kwargs.get("progress"), kwargs.get("result")
       return handler

Alternate implementation (class-based):

    class partial(object):
        def __init__(self):
            self.start = True
        def __call__(self, **kwargs):
            if self.start:
                print "first handler call"
                self.start = False
            print kwargs.get("progress"), kwargs.get("result")






Time Target
--------------------------------------------------------------------------------

Explain that you can always track the elapsed time: demo

Then the remaining time would be nice too ! We can estimate it if
you gave some progress information.

Now, the issue is that you may be calling the breakpoint handler too
frequently or to little. How to cope with that ?

New assumption if you use `dt`: you call `yield` at regular frequency.

Explain `elapsed` and `result`.


Handlers
--------------------------------------------------------------------------------

### Good Enough, Thank you

(rk: in this scheme, we don't know that the early stop was triggered. 
     Better scheme for a precision tracker or that kind of things, 
     an AbortException may be better if we want to be signaled with 
     the early stop).

**Grmph.** Are `raise StopIteration()` and `return result` too ways to do
the same thing ? With the latter being more flexible ? Then we should 
probably NOT present the `StopIteration` scheme ?

### This takes too much time ...

Handler Factories:

    def max_wait(seconds):
        def handler_factory():
            def handler(**kwargs):
                remaining = kwargs.get("remaining")
                if remaining > seconds:
                    raise AbortException(**kwargs)
        return handler_factory

    def max_yields(n):
        def handler_factory():
            yields = [0]
            def handler(**kwargs):
                yields[0] += 1
                if yields[0] > n:
                    raise AbortException(**kwargs)
            return handler
        return handler_factory




